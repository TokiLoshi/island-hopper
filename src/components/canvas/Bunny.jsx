/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import * as THREE from 'three'

const ACTION_MAP = {
  yes: 'CharacterArmature|CharacterArmature|CharacterArmature|Yes',
  wave: 'CharacterArmature|CharacterArmature|CharacterArmature|Wave',
  walkHolding: 'CharacterArmature|CharacterArmature|CharacterArmature|Walk_Holding',
  walk: 'CharacterArmature|CharacterArmature|CharacterArmature|Walk',
  sword: 'CharacterArmature|CharacterArmature|CharacterArmature|Sword',
  sittingStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_Start',
  sittingIdle: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_Idle',
  assemblyEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Assembly_End',
  assemblyLoop: 'CharacterArmature|CharacterArmature|CharacterArmature|Assembly_Loop',
  assemblyStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Assembly_Start',
  chopEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Chop_End',
  chopLoop: 'CharacterArmature|CharacterArmature|CharacterArmature|Chop_Loop',
  chopStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Chop_Start',
  death: 'CharacterArmature|CharacterArmature|CharacterArmature|Death',
  duck: 'CharacterArmature|CharacterArmature|CharacterArmature|Duck',
  hitReact: 'CharacterArmature|CharacterArmature|CharacterArmature|HitReact',
  idle: 'CharacterArmature|CharacterArmature|CharacterArmature|Idle',
  idleHolding: 'CharacterArmature|CharacterArmature|CharacterArmature|Idle_Holding',
  jump: 'CharacterArmature|CharacterArmature|CharacterArmature|Jump',
  jumpIdle: 'CharacterArmature|CharacterArmature|CharacterArmature|Jump_Idle',
  jumpLand: 'CharacterArmature|CharacterArmature|CharacterArmature|Jump_Land',
  no: 'CharacterArmature|CharacterArmature|CharacterArmature|No',
  panEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Pan_End',
  panLoop: 'CharacterArmature|CharacterArmature|CharacterArmature|Pan_Loop',
  panStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Pan_Start',
  punch: 'CharacterArmature|CharacterArmature|CharacterArmature|Punch',
  run: 'CharacterArmature|CharacterArmature|CharacterArmature|Run',
  runHolding: 'CharacterArmature|CharacterArmature|CharacterArmature|Run_Holding',
  sittingEating: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_Eating',
  sittingEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_End',
}

const IDLE_ANIMATION_KEY = 'idle'
const TRANSITION_DURATION = 0.5

export function Bunny({ currentAnimation = IDLE_ANIMATION_KEY, ...props }) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/models/Bunny.glb')
  const { actions } = useAnimations(animations, group)

  const currentActionRef = useRef(null)
  const timeoutRef = useRef(null)

  useEffect(() => {
    if (!actions || Object.keys(actions).length === 0) return

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
      timeoutRef.current = null
    }

    const playIdleAnimation = () => {
      const idleFullName = ACTION_MAP[IDLE_ANIMATION_KEY]
      if (!idleFullName || !actions[idleFullName]) {
        // eslint-disable-next-line no-console
        console.warn(`Idle animation not found ${idleFullName}`)
        return
      }
      const idleAction = actions[idleFullName]
      if (currentActionRef.current) {
        currentActionRef.current.fadeOut(TRANSITION_DURATION)
      }

      idleAction.reset().setLoop(THREE.LoopRepeat, Infinity).fadeIn(TRANSITION_DURATION).play()

      currentActionRef.current = idleAction
    }

    const playRequestedAnimation = (animationKey) => {
      if (animationKey === IDLE_ANIMATION_KEY && currentActionRef.current === actions[ACTION_MAP[IDLE_ANIMATION_KEY]])
        return

      const fullAnimationName = ACTION_MAP[animationKey]
      if (!fullAnimationName) {
        // eslint-disable-next-line no-console
        console.warn(`Animation not found: ${animationKey}`)
        playIdleAnimation()
        return
      }

      const targetAction = actions[fullAnimationName]
      if (currentActionRef.current) {
        currentActionRef.current.fadeOut(TRANSITION_DURATION)
      }

      if (animationKey === IDLE_ANIMATION_KEY) {
        targetAction.reset().setLoop(THREE.LoopRepeat, Infinity).fadeIn(TRANSITION_DURATION).play()
      } else {
        targetAction.reset().setLoop(THREE.LoopRepeat, 1).fadeIn(TRANSITION_DURATION).play()

        const duration = targetAction.getClip().duration * 1000
        timeoutRef.current = setTimeout(
          () => {
            playIdleAnimation()
          },
          duration + TRANSITION_DURATION * 1000,
        )
      }
      currentActionRef.current = targetAction
    }

    playRequestedAnimation(currentAnimation)
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [currentAnimation, actions])

  // ToDo:
  // Set up animations for Onclick Events

  return (
    <group ref={group} {...props} dispose={null}>
      <group name='Root_Scene'>
        <group name='RootNode'>
          <group name='CharacterArmature' rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <primitive object={nodes.Root} />
          </group>
          <skinnedMesh
            name='Rabbit'
            geometry={nodes.Rabbit.geometry}
            material={materials.AtlasMaterial}
            skeleton={nodes.Rabbit.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <skinnedMesh
            name='Eyes'
            geometry={nodes.Eyes.geometry}
            // material={materials.AtlasMaterial}
            material={new THREE.MeshBasicMaterial({ map: materials.AtlasMaterial.map })}
            skeleton={nodes.Eyes.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <skinnedMesh
            name='Hair'
            geometry={nodes.Hair.geometry}
            // material={materials.AtlasMaterial}
            material={new THREE.MeshStandardMaterial({ color: 'rebeccapurple' })}
            // material={new THREE.MeshBasicMaterial({ map: materials.AtlasMaterial.map })}
            skeleton={nodes.Hair.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
        </group>
      </group>
    </group>
  )
}

Bunny.displayName = 'Bunny'
useGLTF.preload('/models/Bunny.glb')
