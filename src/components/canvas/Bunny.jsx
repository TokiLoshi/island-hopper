/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations, useCursor } from '@react-three/drei'
import * as THREE from 'three'
import useStore from '@/store/globalStore'

const ACTION_MAP = {
  yes: 'CharacterArmature|CharacterArmature|CharacterArmature|Yes',
  wave: 'CharacterArmature|CharacterArmature|CharacterArmature|Wave',
  walkHolding: 'CharacterArmature|CharacterArmature|CharacterArmature|Walk_Holding',
  walk: 'CharacterArmature|CharacterArmature|CharacterArmature|Walk',
  sword: 'CharacterArmature|CharacterArmature|CharacterArmature|Sword',
  sittingStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_Start',
  sittingIdle: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_Idle',
  assemblyEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Assembly_End',
  assemblyLoop: 'CharacterArmature|CharacterArmature|CharacterArmature|Assembly_Loop',
  assemblyStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Assembly_Start',
  chopEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Chop_End',
  chopLoop: 'CharacterArmature|CharacterArmature|CharacterArmature|Chop_Loop',
  chopStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Chop_Start',
  death: 'CharacterArmature|CharacterArmature|CharacterArmature|Death',
  duck: 'CharacterArmature|CharacterArmature|CharacterArmature|Duck',
  hitReact: 'CharacterArmature|CharacterArmature|CharacterArmature|HitReact',
  idle: 'CharacterArmature|CharacterArmature|CharacterArmature|Idle',
  idleHolding: 'CharacterArmature|CharacterArmature|CharacterArmature|Idle_Holding',
  jump: 'CharacterArmature|CharacterArmature|CharacterArmature|Jump',
  jumpIdle: 'CharacterArmature|CharacterArmature|CharacterArmature|Jump_Idle',
  jumpLand: 'CharacterArmature|CharacterArmature|CharacterArmature|Jump_Land',
  no: 'CharacterArmature|CharacterArmature|CharacterArmature|No',
  panEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Pan_End',
  panLoop: 'CharacterArmature|CharacterArmature|CharacterArmature|Pan_Loop',
  panStart: 'CharacterArmature|CharacterArmature|CharacterArmature|Pan_Start',
  punch: 'CharacterArmature|CharacterArmature|CharacterArmature|Punch',
  run: 'CharacterArmature|CharacterArmature|CharacterArmature|Run',
  runHolding: 'CharacterArmature|CharacterArmature|CharacterArmature|Run_Holding',
  sittingEating: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_Eating',
  sittingEnd: 'CharacterArmature|CharacterArmature|CharacterArmature|Sitting_End',
}

const IDLE_ANIMATION_KEY = 'sittingIdle'
const TRANSITION_DURATION = 0.5

export function Bunny({ currentAnimation = IDLE_ANIMATION_KEY, ...props }) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/models/Bunny.glb')
  const { actions } = useAnimations(animations, group)

  const currentActionRef = useRef(null)
  const timeoutRef = useRef(null)

  const [isClicked, setIsClicked] = useState(false)
  const [hovered, setHovered] = useState(false)
  useCursor(hovered /*'pointer', 'auto', document.body*/)

  useEffect(() => {
    if (!actions || Object.keys(actions).length === 0) return

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
      timeoutRef.current = null
    }

    const playIdleAnimation = () => {
      const idleFullName = ACTION_MAP[IDLE_ANIMATION_KEY]
      if (!idleFullName || !actions[idleFullName]) {
        // eslint-disable-next-line no-console
        console.warn(`Idle animation not found ${idleFullName}`)
        return
      }
      const idleAction = actions[idleFullName]
      if (currentActionRef.current) {
        currentActionRef.current.fadeOut(TRANSITION_DURATION)
      }

      idleAction.reset().setLoop(THREE.LoopRepeat, Infinity).fadeIn(TRANSITION_DURATION).play()

      currentActionRef.current = idleAction
    }

    const playRequestedAnimation = (animationKey) => {
      if (animationKey === IDLE_ANIMATION_KEY && currentActionRef.current === actions[ACTION_MAP[IDLE_ANIMATION_KEY]])
        return

      const fullAnimationName = ACTION_MAP[animationKey]
      if (!fullAnimationName) {
        // eslint-disable-next-line no-console
        console.warn(`Animation not found: ${animationKey}`)
        playIdleAnimation()
        return
      }

      const targetAction = actions[fullAnimationName]
      if (currentActionRef.current) {
        currentActionRef.current.fadeOut(TRANSITION_DURATION)
      }

      if (animationKey === IDLE_ANIMATION_KEY) {
        targetAction.reset().setLoop(THREE.LoopRepeat, Infinity).fadeIn(TRANSITION_DURATION).play()
      } else {
        targetAction.reset().setLoop(THREE.LoopRepeat, 1).fadeIn(TRANSITION_DURATION).play()

        const duration = targetAction.getClip().duration * 1000
        timeoutRef.current = setTimeout(
          () => {
            playIdleAnimation()
          },
          duration + TRANSITION_DURATION * 1000,
        )
      }
      currentActionRef.current = targetAction
    }

    playRequestedAnimation(currentAnimation)
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [currentAnimation, actions])

  const { audioEnabled, dialogAudioPlaying } = useStore()

  const audioRef = useRef()
  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioRef.current = new Audio('./soundEffects/bunnyHi.mp3')
      audioRef.current.preload = 'auto'
    }
  }, [])

  const handleClick = (event) => {
    event.stopPropagation()
    if (audioRef.current && audioEnabled && !dialogAudioPlaying) {
      audioRef.current.currentTime = 0
      audioRef.current.play().catch((error) => {
        // eslint-disable-next-line no-console
        console.log('error playing bunny audio: ', error)
      })
    }
    setIsClicked(true)
    // if current animation fade out
    if (currentActionRef.current) {
      currentActionRef.current.fadeOut(TRANSITION_DURATION)
    }
    const actionName = ACTION_MAP['idleHolding']
    const actionToPlay = actions[actionName]
    actionToPlay.reset().setLoop(THREE.LoopRepeat, 1).fadeIn(TRANSITION_DURATION).play()

    const duration = actionToPlay.getClip().duration * 1000

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }

    timeoutRef.current = setTimeout(
      () => {
        const idleAnimation = ACTION_MAP[IDLE_ANIMATION_KEY]
        const idleAction = actions[idleAnimation]
        if (currentActionRef.current) {
          currentActionRef.current.fadeOut(TRANSITION_DURATION)
        }
        idleAction.reset().setLoop(THREE.LoopRepeat, Infinity).fadeIn(TRANSITION_DURATION).play()
        currentActionRef.current = idleAction
        setIsClicked(false)
      },
      duration + TRANSITION_DURATION * 1000,
    )
    currentActionRef.current = actionToPlay
  }

  return (
    <group
      ref={group}
      {...props}
      dispose={null}
      onClick={handleClick}
      onPointerOver={() => setHovered(true)}
      onPointerOut={() => setHovered(false)}
    >
      <group name='Root_Scene'>
        <group name='RootNode'>
          <group name='CharacterArmature' rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <primitive object={nodes.Root} />
          </group>
          <skinnedMesh
            name='Rabbit'
            geometry={nodes.Rabbit.geometry}
            material={materials.AtlasMaterial}
            skeleton={nodes.Rabbit.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <skinnedMesh
            name='Eyes'
            geometry={nodes.Eyes.geometry}
            // material={materials.AtlasMaterial}
            material={new THREE.MeshBasicMaterial({ map: materials.AtlasMaterial.map })}
            skeleton={nodes.Eyes.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
          <skinnedMesh
            name='Hair'
            geometry={nodes.Hair.geometry}
            // material={materials.AtlasMaterial}
            material={new THREE.MeshStandardMaterial({ color: 'rebeccapurple' })}
            // material={new THREE.MeshBasicMaterial({ map: materials.AtlasMaterial.map })}
            skeleton={nodes.Hair.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={100}
          />
        </group>
      </group>
    </group>
  )
}

Bunny.displayName = 'Bunny'
useGLTF.preload('/models/Bunny.glb')
